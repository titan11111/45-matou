<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>ゼルダ風ミニゲーム v1</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111827cc;
      --accent:#38bdf8;
      --accent2:#a78bfa;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0; background:
        radial-gradient(1200px 700px at 70% -20%, #1f2937 0%, #0b1020 60%),
        radial-gradient(800px 600px at -10% 110%, #111827 0%, #0b1020 70%);
      color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display:flex; flex-direction:column; align-items:center; gap:12px; padding:16px 12px 96px;
    }
    header{width:100%; max-width:920px; display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .title{display:flex; align-items:center; gap:10px;}
    .logo{width:40px; height:40px; border-radius:12px; background:linear-gradient(135deg,#38bdf8,#a78bfa); box-shadow:var(--shadow);}    
    h1{font-size:20px; margin:0; letter-spacing:.03em;}
    .btn{border:1px solid #334155; color:var(--text); background:linear-gradient(180deg,#0f172a,#0b1329); padding:8px 12px; border-radius:12px; cursor:pointer; display:inline-flex; gap:8px; align-items:center; box-shadow:var(--shadow);}
    .btn:hover{border-color:#475569}

    .frame{position:relative; width:100%; max-width:920px; aspect-ratio:16/9; border-radius:20px; overflow:hidden; background:#0a0f1e; box-shadow:var(--shadow); border:1px solid #22314d;}
    canvas{width:100%; height:100%; image-rendering: pixelated; display:block;}

    .hud{position:absolute; inset:12px; pointer-events:none;}
    .hud .tag{pointer-events:auto; position:absolute; top:0; right:0; padding:6px 10px; background:var(--panel); border:1px solid #273244; border-radius:999px; font-size:12px; color:var(--muted);}

    .dialog{position:absolute; left:50%; transform:translateX(-50%); bottom:10px; width:min(92%,820px); background:var(--panel); border:1px solid #273244; border-radius:16px; padding:10px 14px; display:none;}
    .dialog.show{display:block;}

    .mobile-only{display:none}

    /* On-screen controls */
    @media (hover:none){
      .mobile-only{display:block}
      .pad{position:fixed; left:14px; bottom:14px; width:160px; height:160px; opacity:.96;}
      .pad .btnDir{position:absolute; width:56px; height:56px; border-radius:12px; border:1px solid #2b3a58; background:#0c1530cc; color:#94a3b8; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:none;}
      .pad .btnDir:active{background:#0d1b42}
      .pad .u{left:52px; top:0}
      .pad .d{left:52px; bottom:0}
      .pad .l{left:0; top:52px}
      .pad .r{right:0; top:52px}

      .action{position:fixed; right:18px; bottom:28px; display:flex; gap:14px;}
      .action .btnAct{width:72px; height:72px; border-radius:50%; border:2px solid #2b3a58; background:radial-gradient(circle at 30% 30%, #1a2a55, #0c1530); color:#dbeafe; font-weight:700; font-size:14px; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:none;}
      .action .btnAct:active{transform:scale(.98)}
    }

    footer{position:fixed; left:0; right:0; bottom:10px; display:flex; justify-content:center;}
    .bar{display:flex; gap:8px; align-items:center; background:var(--panel); border:1px solid #273244; padding:6px 10px; border-radius:999px; font-size:12px;}
    .pill{padding:6px 10px; border-radius:999px; background:#0b1329; border:1px solid #22314d; color:#9fb4d6}
  </style>
</head>
<body>
  <header>
    <div class="title">
      <div class="logo"></div>
      <h1>ゼルダ風ミニゲーム v1（HTML/CSS/JS）</h1>
    </div>
    <button id="helpBtn" class="btn" aria-label="ヘルプ">❓ ヘルプ</button>
  </header>

  <div class="frame">
    <canvas id="game" width="320" height="180" aria-label="ゲーム画面"></canvas>
    <div class="hud">
      <div class="tag">WASD / ⬆︎⬇︎⬅︎➡︎ ＋ J（攻撃）｜モバイルは画面ボタン</div>
      <div id="dialog" class="dialog" role="dialog" aria-live="polite"></div>
    </div>
  </div>

  <!-- Mobile Controls -->
  <div class="mobile-only pad" aria-hidden="true">
    <div class="btnDir u" data-dir="up">▲</div>
    <div class="btnDir d" data-dir="down">▼</div>
    <div class="btnDir l" data-dir="left">◀</div>
    <div class="btnDir r" data-dir="right">▶</div>
  </div>
  <div class="mobile-only action" aria-hidden="true">
    <div class="btnAct" id="btnAttack">J</div>
  </div>

  <footer>
    <div class="bar">
      <span class="pill">v1 基礎実装：移動 / 当たり判定 / 草伐り / 宝箱 / NPC会話 / モバイル操作</span>
    </div>
  </footer>

  <script>
  // ====== Utility & Setup ======
  const $ = sel => document.querySelector(sel);
  const canvas = $('#game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(3, Math.floor(window.devicePixelRatio||1)));
  // Keep internal resolution fixed (pixel-art) while letting CSS scale
  canvas.width = 320 * DPR; canvas.height = 180 * DPR; ctx.imageSmoothingEnabled = false; ctx.scale(DPR, DPR);

  const TILE = 16; // px
  const VW = 320; // virtual width
  const VH = 180; // virtual height

  // RNG helper
  const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  // Input state
  const input = { up:false, down:false, left:false, right:false, attack:false };
  const keys = new Map([
    ['ArrowUp','up'],['KeyW','up'],
    ['ArrowDown','down'],['KeyS','down'],
    ['ArrowLeft','left'],['KeyA','left'],
    ['ArrowRight','right'],['KeyD','right'],
    ['KeyJ','attack'],['Space','attack']
  ]);
  addEventListener('keydown',e=>{ const k=keys.get(e.code); if(k){ input[k]=true; if(['attack'].includes(k)) e.preventDefault(); }});
  addEventListener('keyup',e=>{ const k=keys.get(e.code); if(k) input[k]=false; });

  // Touch controls
  for (const el of document.querySelectorAll('.btnDir')){
    const dir = el.dataset.dir;
    const on = ()=> input[dir]=true;
    const off = ()=> input[dir]=false;
    el.addEventListener('touchstart', e=>{ e.preventDefault(); on(); }, {passive:false});
    el.addEventListener('touchend', off);
    el.addEventListener('touchcancel', off);
    el.addEventListener('mousedown', on);
    el.addEventListener('mouseup', off);
    el.addEventListener('mouseleave', off);
  }
  const btnAttack = $('#btnAttack');
  if(btnAttack){
    const press = ()=>{ input.attack=true; setTimeout(()=>input.attack=false, 40); };
    btnAttack.addEventListener('touchstart', e=>{ e.preventDefault(); press(); }, {passive:false});
    btnAttack.addEventListener('mousedown', press);
  }

  // Dialog UI
  const dialogBox = $('#dialog');
  let dialogTimer = 0; // frames remaining
  function say(text, ms=2200){
    dialogBox.textContent = text; dialogBox.classList.add('show');
    dialogTimer = Math.ceil(ms/16);
  }
  $('#helpBtn').addEventListener('click',()=>{
    say('操作：WASD/矢印で移動、Jまたはスペースで攻撃（会話/宝箱）。草を刈るとルピー！ NPCに近づいてJで会話。水と木は通れません。');
  });

  // ====== Map Generation ======
  const MAP_W = 64, MAP_H = 64;
  // Tiles: 0=草,1=木(壁),2=水(壁),3=背の高い草(壊れる)
  const map = Array.from({length:MAP_H},(_,y)=>Array.from({length:MAP_W},(_,x)=>0));
  // Border walls
  for(let y=0;y<MAP_H;y++)for(let x=0;x<MAP_W;x++){
    if(x===0||y===0||x===MAP_W-1||y===MAP_H-1) map[y][x]=1;
  }
  // Lakes
  for(let i=0;i<8;i++){
    const cx=rand(6,MAP_W-6), cy=rand(6,MAP_H-6), r=rand(2,4);
    for(let y=-r;y<=r;y++)for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r*r && map[cy+y] && map[cy+y][cx+x]!==undefined) map[cy+y][cx+x]=2;
    }
  }
  // Forest blobs
  for(let i=0;i<30;i++){
    const cx=rand(3,MAP_W-4), cy=rand(3,MAP_H-4), r=rand(1,3);
    for(let y=-r;y<=r;y++)for(let x=-r;x<=r;x++){
      if(Math.abs(x)+Math.abs(y)<=r && map[cy+y] && map[cy+y][cx+x]!==undefined) map[cy+y][cx+x]=1;
    }
  }
  // Tall grass patches
  for(let i=0;i<50;i++){
    const cx=rand(2,MAP_W-3), cy=rand(2,MAP_H-3), r=rand(1,2);
    for(let y=-r;y<=r;y++)for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r*r && map[cy+y] && map[cy+y][cx+x]===0) map[cy+y][cx+x]=3;
    }
  }

  // ====== Entities ======
  const entities = [];
  function addNPC(tx,ty,msg){ entities.push({type:'npc', x:tx*TILE+8, y:ty*TILE+12, w:10, h:12, msg}); }
  function addChest(tx,ty,loot){ entities.push({type:'chest', x:tx*TILE+4, y:ty*TILE+8, w:12, h:12, opened:false, loot}); }

  // Place a small village area (clear grass)
  const village = {x:8,y:8,w:10,h:8};
  for(let y=village.y;y<village.y+village.h;y++){
    for(let x=village.x;x<village.x+village.w;x++){
      if(map[y] && map[y][x]!==undefined) map[y][x]=0;
    }
  }
  addNPC(village.x+4, village.y+3, 'ようこそ、はじまりの原っぱへ！ 草を刈ってお小遣いを稼ごう。');
  addNPC(village.x+7, village.y+5, '宝箱はJで開けられるよ。水と木は通れないから気をつけて！');
  addChest(village.x+5, village.y+2, {rupees:5});

  // Random chests
  for(let i=0;i<6;i++){
    const rx=rand(2,MAP_W-3), ry=rand(2,MAP_H-3);
    if(map[ry][rx]===0) addChest(rx,ry,{rupees:rand(1,3)});
  }

  // ====== Player ======
  const player = {
    x:(village.x+2)*TILE+8,
    y:(village.y+4)*TILE+8,
    w:10, h:12,
    spd:1.2,
    dir:'down', // 'up'|'down'|'left'|'right'
    attacking:false,
    atkTimer:0,
    hearts:3, maxHearts:3,
    rupees: Number(localStorage.getItem('rupees')||0)
  };

  function save(){ localStorage.setItem('rupees', String(player.rupees)); }

  // ====== Collision ======
  function tileAt(px,py){
    const tx = Math.floor(px/TILE), ty = Math.floor(py/TILE);
    if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return 1; // treat out of bounds as wall
    return map[ty][tx];
  }
  function blocked(px,py,w,h){
    // check four corners
    const corners = [
      [px,py], [px+w,py], [px,py+h], [px+w,py+h]
    ];
    for(const [cx,cy] of corners){
      const t = tileAt(cx,cy);
      if(t===1||t===2) return true;
    }
    return false;
  }

  // ====== Rendering (tiny software sprites) ======
  const draw = {
    rect:(x,y,w,h,fill,stroke)=>{ ctx.fillStyle=fill; ctx.fillRect(x,y,w,h); if(stroke){ ctx.strokeStyle=stroke; ctx.strokeRect(x+.5,y+.5,w-1,h-1);} },
    tile:(x,y,t)=>{
      // Grass base
      if(t===0){
        ctx.fillStyle = '#1b4d2b'; ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle = '#226a38'; for(let i=0;i<4;i++){ ctx.fillRect(x+rand(1,12), y+rand(1,12), 2,2);}        
      } else if(t===1){ // Tree/Wall
        ctx.fillStyle = '#214b1f'; ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle = '#163417'; ctx.fillRect(x+2,y+2,12,12);
      } else if(t===2){ // Water
        ctx.fillStyle = '#0b3a6b'; ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle = '#0e58a5'; ctx.fillRect(x+1,y+1,TILE-2,TILE-2);
      } else if(t===3){ // Tall grass (breakable)
        ctx.fillStyle = '#1f5b2f'; ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle = '#2a7d40'; for(let i=0;i<6;i++){ ctx.fillRect(x+rand(1,12), y+rand(1,12), 2,2);}        
      }
    },
    player:(x,y,dir,attack)=>{
      // body
      ctx.fillStyle = '#fef3c7'; ctx.fillRect(x-5, y-10, 10, 10); // head
      ctx.fillStyle = '#10b981'; ctx.fillRect(x-6, y, 12, 12); // tunic
      // eyes
      ctx.fillStyle = '#0f172a'; if(dir==='left') ctx.fillRect(x-4,y-6,2,2); else if(dir==='right') ctx.fillRect(x+2,y-6,2,2); else ctx.fillRect(x-2,y-6,4,2);
      // sword (simple line)
      if(attack){
        ctx.strokeStyle = '#d1d5db'; ctx.lineWidth=2;
        ctx.beginPath();
        if(dir==='up'){ ctx.moveTo(x, y-12); ctx.lineTo(x, y-20); }
        else if(dir==='down'){ ctx.moveTo(x, y+12); ctx.lineTo(x, y+20); }
        else if(dir==='left'){ ctx.moveTo(x-8, y+2); ctx.lineTo(x-18, y+2); }
        else { ctx.moveTo(x+8, y+2); ctx.lineTo(x+18, y+2); }
        ctx.stroke();
      }
    },
    npc:(e)=>{
      ctx.fillStyle = '#eab308'; ctx.fillRect(e.x-5,e.y-10,10,10); // head
      ctx.fillStyle = '#334155'; ctx.fillRect(e.x-6,e.y,12,12); // robe
      // name bubble
      ctx.fillStyle = '#94a3b8'; ctx.fillRect(e.x-6,e.y-14,12,3);
    },
    chest:(e)=>{
      ctx.fillStyle = e.opened ? '#6b7280' : '#b45309';
      ctx.fillRect(e.x, e.y, 12, 10);
      ctx.fillStyle = '#78350f'; ctx.fillRect(e.x+1, e.y+6, 10, 2);
      if(!e.opened){ ctx.fillStyle = '#fde68a'; ctx.fillRect(e.x+5, e.y+4, 2, 3); }
    },
    hud:()=>{
      // hearts
      for(let i=0;i<player.maxHearts;i++){
        const x = 10 + i*14, y=8;
        ctx.fillStyle = i<player.hearts? '#ef4444' : '#475569';
        ctx.fillRect(x,y,10,8);
      }
      // rupees
      ctx.fillStyle='#34d399'; ctx.fillRect( VW-80, 8, 10, 10 );
      ctx.fillStyle='#cbd5e1'; ctx.font='8px ui-sans-serif'; ctx.fillText('x ' + player.rupees, VW-64, 16);
    }
  };

  // ====== Camera ======
  const camera = {x:0,y:0};
  function centerCamera(){
    camera.x = Math.floor(player.x - VW/2); camera.y = Math.floor(player.y - VH/2);
    camera.x = Math.max(0, Math.min(camera.x, MAP_W*TILE - VW));
    camera.y = Math.max(0, Math.min(camera.y, MAP_H*TILE - VH));
  }

  // ====== Attack & Interactions ======
  function doAttack(){
    if(player.attacking) return;
    player.attacking = true; player.atkTimer = 8; // ~130ms
    // Hitbox
    const range = 14;
    let hx=player.x, hy=player.y, hw=12, hh=12;
    if(player.dir==='up'){ hy-=range; hh=12; }
    else if(player.dir==='down'){ hy+=range; hh=12; }
    else if(player.dir==='left'){ hx-=range; hw=12; }
    else { hx+=range; hw=12; }

    // Destroy tall grass => rupee
    const tx = Math.floor(hx/TILE), ty = Math.floor(hy/TILE);
    for(let y=-1;y<=1;y++)for(let x=-1;x<=1;x++){
      const gx = tx+x, gy = ty+y;
      if(map[gy] && map[gy][gx]===3){ map[gy][gx]=0; if(Math.random()<0.5){ player.rupees++; save(); } }
    }

    // Interact with nearby entities
    for(const e of entities){
      if(Math.abs(e.x - player.x) < 16 && Math.abs(e.y - player.y) < 16){
        if(e.type==='npc'){
          say(e.msg);
        } else if(e.type==='chest' && !e.opened){
          e.opened = true; const get = e.loot?.rupees||0; player.rupees += get; save();
          say(`宝箱：ルピー ${get} 枚を手に入れた！`);
        }
      }
    }
  }

  // ====== Game Loop ======
  function step(){
    // Input -> velocity
    let vx = (input.right?1:0) - (input.left?1:0);
    let vy = (input.down?1:0) - (input.up?1:0);
    if(vx||vy){
      if(Math.abs(vx)>Math.abs(vy)) player.dir = vx>0?'right':'left';
      else player.dir = vy>0?'down':'up';
    }

    const speed = player.spd * (input.up||input.down||input.left||input.right?1:0);
    // move X
    let nx = player.x + vx*speed; if(!blocked(nx-player.w/2, player.y-player.h/2, player.w, player.h)) player.x=nx;
    // move Y
    let ny = player.y + vy*speed; if(!blocked(player.x-player.w/2, ny-player.h/2, player.w, player.h)) player.y=ny;

    if(input.attack) doAttack();
    if(player.attacking){ player.atkTimer--; if(player.atkTimer<=0){ player.attacking=false; }}

    if(dialogTimer>0){ dialogTimer--; if(dialogTimer===0){ dialogBox.classList.remove('show'); }}

    centerCamera();
  }

  function render(){
    ctx.clearRect(0,0,VW,VH);
    // draw tiles (only visible)
    const sx = Math.floor(camera.x/TILE), sy = Math.floor(camera.y/TILE);
    const ex = Math.ceil((camera.x+VW)/TILE), ey = Math.ceil((camera.y+VH)/TILE);
    for(let ty=sy; ty<ey; ty++){
      for(let tx=sx; tx<ex; tx++){
        const t = (map[ty]&&map[ty][tx]!==undefined)? map[ty][tx]:1;
        draw.tile(tx*TILE-camera.x, ty*TILE-camera.y, t);
      }
    }
    // entities
    for(const e of entities){
      const exx = e.x - camera.x, eyy = e.y - camera.y;
      if(exx<-20||exx>VW+20||eyy<-20||eyy>VH+20) continue;
      if(e.type==='npc') draw.npc(e);
      else if(e.type==='chest') draw.chest(e);
    }
    // player
    draw.player(player.x - camera.x, player.y - camera.y, player.dir, player.attacking);

    // HUD
    draw.hud();
  }

  function loop(){ step(); render(); requestAnimationFrame(loop); }
  loop();

  // Show help at start (once)
  if(!localStorage.getItem('zelda_help_shown')){
    setTimeout(()=>{
      say('操作：WASD/矢印で移動、J/スペースで攻撃（会話/宝箱）。草を刈るとルピー。もう一度❓でヘルプ。');
      localStorage.setItem('zelda_help_shown','1');
    }, 400);
  }
  </script>
</body>
</html>
